import datetime

import aiogram.types
from aiogram.fsm.context import FSMContext
from app.bot.handlers.base import BaseHandler
from app.bot.keyboards.budget import BudgetKeyboard
from app.bot.states import BudgetState
from app.utils.request import RequestManager
from app.exceptions.request_exceptions import TokenStorageError, RequestError
from app.utils.logger import logger

class GetUserBudgetInfoHandler(BaseHandler):
    async def handle(self, event, state: FSMContext, context: dict = None):
        logger.debug(f"[{self.__class__.__name__}] –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –±—é–¥–∂–µ—Ç–∞—Ö –∞–≤—Ç–æ—Ä–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {event.from_user.id}")
        try:
            request_manager = RequestManager()
            data = await request_manager.make_request(method='GET', url=f'budget?month={datetime.datetime.utcnow().month}&year={datetime.datetime.utcnow().year}', state=state)
            if context is None:
                context = {}
            context['budgets'] = data
            return await super().handle(event, state, context)
        except TokenStorageError as e:
            logger.error(f"[{self.__class__.__name__}] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å —Ç–æ–∫–µ–Ω–∞–º–∏: {event.from_user.id}")
            text, markup = e.to_user_message_with_markup()
            await event.answer(text, reply_markup=markup)
            return False
        except RequestError as e:
            logger.error(
                f"[{self.__class__.__name__}] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {event.from_user.id}")
            text, markup = e.to_user_message_with_markup()
            await event.answer(text, reply_markup=markup)
            return False
        except Exception as e:
            logger.exception(f"[{self.__class__.__name__}] –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –±—é–¥–∂–µ—Ç–∞—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
            await event.answer("üö® –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ –ø–æ–∑–∂–µ.")
            return False

class CheckUserBudgetsInfoHandler(BaseHandler):
    async def handle(self, event, state: FSMContext, context: dict = None):
        logger.debug(f"[{self.__class__.__name__}] –ü—Ä–æ–≤–µ—Ä–∫–∞ –±—é–¥–∂–µ—Ç–æ–≤ –∞–≤—Ç–æ—Ä–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {event.from_user.id}")
        try:
            budgets = context['budgets']
            if len(budgets) == 0:
                await event.message.edit_text(text='–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –Ω–∏ –µ–¥–∏–Ω–æ–≥–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –±—é–¥–∂–µ—Ç–∞!', reply_markup=BudgetKeyboard().get_empty_budgets_menu_keyboard())
            else:
                await state.update_data(budgets=budgets)
                return await super().handle(event, state, context)
        except TokenStorageError as e:
            logger.error(f"[{self.__class__.__name__}] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å —Ç–æ–∫–µ–Ω–∞–º–∏: {event.from_user.id}")
            text, markup = e.to_user_message_with_markup()
            await event.answer(text, reply_markup=markup)
            return False
        except RequestError as e:
            logger.error(
                f"[{self.__class__.__name__}] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {event.from_user.id}")
            text, markup = e.to_user_message_with_markup()
            await event.answer(text, reply_markup=markup)
            return False
        except Exception as e:
            logger.exception(f"[{self.__class__.__name__}] –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
            await event.answer("üö® –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ –ø–æ–∑–∂–µ.")
            return False

class GetCategoryInfoForBudgetsHandler(BaseHandler):
    async def handle(self, event, state: FSMContext, context: dict = None):
        logger.debug(f"[{self.__class__.__name__}] –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è—Ö –±—é–¥–∂–µ—Ç–æ–≤ –∞–≤—Ç–æ—Ä–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {event.from_user.id}")
        try:
            budgets = context['budgets']
            entity_list = await RequestManager().fetch_and_attach_entity_info(
                budgets,
                field_name='category_id',
                api_path_template='settings/categories/set',
                state=state
            )
            if entity_list is not None:
                entity_map = {entity['id']: entity for entity in entity_list}
                for budget in budgets:
                    entity_id = budget.get('category_id')
                    if entity_id and entity_id in entity_map:
                        budget['category'] = entity_map[entity_id]

            return await super().handle(event, state, context)
        except TokenStorageError as e:
            logger.error(f"[{self.__class__.__name__}] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å —Ç–æ–∫–µ–Ω–∞–º–∏: {event.from_user.id}")
            text, markup = e.to_user_message_with_markup()
            await event.answer(text, reply_markup=markup)
            return False
        except RequestError as e:
            logger.error(
                f"[{self.__class__.__name__}] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {event.from_user.id}")
            text, markup = e.to_user_message_with_markup()
            await event.answer(text, reply_markup=markup)
            return False
        except Exception as e:
            logger.exception(f"[{self.__class__.__name__}] –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –±—é–¥–∂–µ—Ç–∞—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
            await event.answer("üö® –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ –ø–æ–∑–∂–µ.")
            return False

class GetSubcategoryInfoForBudgetsHandler(BaseHandler):
    async def handle(self, event, state: FSMContext, context: dict = None):
        logger.debug(f"[{self.__class__.__name__}] –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø–æ–¥-–∫–∞—Ç–µ–≥–æ—Ä–∏—è—Ö –±—é–¥–∂–µ—Ç–æ–≤ –∞–≤—Ç–æ—Ä–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {event.from_user.id}")
        try:
            budgets = context['budgets']
            entity_list = await RequestManager().fetch_and_attach_entity_info(
                budgets,
                field_name='subcategory_id',
                api_path_template='settings/subcategory/set',
                state=state
            )
            if entity_list is not None:
                entity_map = {entity['id']: entity for entity in entity_list }
                for budget in budgets:
                    entity_id = budget.get('subcategory_id')
                    if entity_id and entity_id in entity_map:
                        budget['subcategory'] = entity_map[entity_id]

            return await super().handle(event, state, context)
        except TokenStorageError as e:
            logger.error(f"[{self.__class__.__name__}] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å —Ç–æ–∫–µ–Ω–∞–º–∏: {event.from_user.id}")
            text, markup = e.to_user_message_with_markup()
            await event.answer(text, reply_markup=markup)
            return False
        except RequestError as e:
            logger.error(
                f"[{self.__class__.__name__}] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {event.from_user.id}")
            text, markup = e.to_user_message_with_markup()
            await event.answer(text, reply_markup=markup)
            return False
        except Exception as e:
            logger.exception(f"[{self.__class__.__name__}] –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –±—é–¥–∂–µ—Ç–∞—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
            await event.answer("üö® –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ –ø–æ–∑–∂–µ.")
            return False

class GetUserCashboxInfoForBudgetsHandler(BaseHandler):
    async def handle(self, event, state: FSMContext, context: dict = None):
        logger.debug(f"[{self.__class__.__name__}] –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –∫—ç—à-–±–æ–∫—Å–∞—Ö –±—é–¥–∂–µ—Ç–æ–≤ –∞–≤—Ç–æ—Ä–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {event.from_user.id}")
        try:
            budgets = context['budgets']
            entity_list = await RequestManager().fetch_and_attach_entity_info(
                budgets,
                field_name='user_cashbox_id',
                api_path_template='auth/me/cashboxes/set',
                state=state
            )
            if entity_list is not None:
                entity_map = {entity['id']: entity for entity in entity_list}
                for budget in budgets:
                    entity_id = budget.get('user_cashbox_id')
                    if entity_id and entity_id in entity_map:
                        budget['user_cashbox'] = entity_map[entity_id]

            return await super().handle(event, state, context)
        except TokenStorageError as e:
            logger.error(f"[{self.__class__.__name__}] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å —Ç–æ–∫–µ–Ω–∞–º–∏: {event.from_user.id}")
            text, markup = e.to_user_message_with_markup()
            await event.answer(text, reply_markup=markup)
            return False
        except RequestError as e:
            logger.error(
                f"[{self.__class__.__name__}] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {event.from_user.id}")
            text, markup = e.to_user_message_with_markup()
            await event.answer(text, reply_markup=markup)
            return False
        except Exception as e:
            logger.exception(f"[{self.__class__.__name__}] –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –±—é–¥–∂–µ—Ç–∞—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
            await event.answer("üö® –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ –ø–æ–∑–∂–µ.")
            return False


class CheckUserBudgetsAdditionalInfoHandler(BaseHandler):
    async def handle(self, event, state: FSMContext, context: dict = None):
        logger.debug(
            f"[{self.__class__.__name__}] –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –±—é–¥–∂–µ—Ç–∞—Ö –∞–≤—Ç–æ—Ä–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {event.from_user.id}")
        try:
            budgets = context['budgets']
            if any(
                    budget.get('category') is None and
                    budget.get('subcategory') is None and
                    budget.get('user_cashbox') is None
                    for budget in budgets
            ):
                await event.message.edit_text(text='–ü—Ä–æ–∏–∑–æ—à–ª–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å –≤–∞—à–∏–º –±—é–¥–∂–µ—Ç–æ–º!\n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É!',
                                              reply_markup=BudgetKeyboard().get_empty_budgets_menu_keyboard())
            else:
                await state.update_data(budgets=budgets)
                return await super().handle(event, state, context)
        except TokenStorageError as e:
            logger.error(f"[{self.__class__.__name__}] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å —Ç–æ–∫–µ–Ω–∞–º–∏: {event.from_user.id}")
            text, markup = e.to_user_message_with_markup()
            await event.answer(text, reply_markup=markup)
            return False
        except RequestError as e:
            logger.error(
                f"[{self.__class__.__name__}] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {event.from_user.id}")
            text, markup = e.to_user_message_with_markup()
            await event.answer(text, reply_markup=markup)
            return False
        except Exception as e:
            logger.exception(f"[{self.__class__.__name__}] –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
            await event.answer("üö® –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ –ø–æ–∑–∂–µ.")
            return False


class ShowUserBudgetsHandler(BaseHandler):
    async def handle(self, event, state: FSMContext, context: dict = None):
        logger.debug(
            f"[{self.__class__.__name__}] –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –±—é–¥–∂–µ—Ç–æ–≤ –∞–≤—Ç–æ—Ä–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {event.from_user.id}")
        try:
            await state.set_state(BudgetState.choosing_budget_item)

            data = await state.get_data()
            budgets = data.get('budgets')

            index = data.get("budget_index", 0)
            budget = budgets[index]

            await event.message.edit_text(self._format_budget(budget, index, len(budgets)),
                                          reply_markup=BudgetKeyboard().get_user_budgets_menu_keyboard(),
                                          parse_mode='HTML')
            return True
        except Exception as e:
            logger.exception(
                f"[{self.__class__.__name__}] –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –∫—ç—à-–±–æ–∫—Å–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
            await event.answer("üö® –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ –ø–æ–∑–∂–µ.")
            return False

    def _format_budget(self, budget: dict, index: int, total: int) -> str:
        category = budget.get("category", {})
        subcategory = budget.get("subcategory", {})
        user_cashbox = budget.get("user_cashbox", {})
        user = budget.get("user", {})

        return (
            f"üìä <b>–ë—é–¥–∂–µ—Ç</b> {index + 1}/{total}\n\n"
            f"üóÇÔ∏è <b>–ö–∞—Ç–µ–≥–æ—Ä–∏—è:</b> {(category.get('name', '‚Äî'))}\n"
            f"üìÅ <b>–ü–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è:</b> {(subcategory.get('name', '‚Äî'))}\n"
            f"üíº <b>–ö—ç—à–±–æ–∫—Å:</b> {(user_cashbox.get('custom_name') or user_cashbox.get('name', '‚Äî'))}\n"
            f"üìÖ <b>–ú–µ—Å—è—Ü:</b> {budget.get('month')}.{budget.get('year')}\n"
            f"üí∞ <b>–°—É–º–º–∞:</b> {budget.get('amount')} {(budget.get('currency', '‚Äî'))}\n"
            f"üîÅ <b>–ü–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è:</b> {'–î–∞' if budget.get('is_recurring') else '–ù–µ—Ç'}\n"
            f"üîí <b>–ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω:</b> {'–î–∞' if budget.get('is_locked') else '–ù–µ—Ç'}\n"
            f"‚úèÔ∏è <b>–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:</b> {(budget.get('comment', '‚Äî'))}\n"
            f"üë§ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b> {(user.get('first_name', ''))} {(user.get('last_name', ''))} (@{user.get('username', '‚Äî')})"
        )


class  CheckChosenBudgetHandler(BaseHandler):
    async def handle(self, event, state: FSMContext, context: dict = None):
        logger.debug(f"[{self.__class__.__name__}] –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –±—é–¥–∂–µ—Ç–∞ –∞–≤—Ç–æ—Ä–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {event.from_user.id}")
        try:
            data = await state.get_data()
            budgets = data.get('budgets')

            index = data.get("budget_index", 0)
            budget = budgets[index]

            if context is None:
                context = {}
            context['budget'] = budget

            if budget['id']:
                return await super().handle(event, state, context)
            else:
                Exception('—á–µ—Ç–æ –Ω–µ —Ç–∞–∫')
        except Exception as e:
            logger.exception(
                f"[{self.__class__.__name__}] –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –∫—ç—à-–±–æ–∫—Å–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
            await event.answer("üö® –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ –ø–æ–∑–∂–µ.")
            return False


class GetDetailBudgetInfoHandler(BaseHandler):
    async def handle(self, event, state: FSMContext, context: dict = None):
        logger.debug(f"[{self.__class__.__name__}] –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –±—é–¥–∂–µ—Ç–∞ –∞–≤—Ç–æ—Ä–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {event.from_user.id}")
        try:
            budget = context['budgets']
            request_manager = RequestManager()
            data = await request_manager.make_request(method='GET', url=f'budget/{budget["id"]}', state=state)
            context["detail_budget"] = data
            return await super().handle(event, state, context)
        except TokenStorageError as e:
            logger.error(f"[{self.__class__.__name__}] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å —Ç–æ–∫–µ–Ω–∞–º–∏: {event.from_user.id}")
            text, markup = e.to_user_message_with_markup()
            await event.answer(text, reply_markup=markup)
            return False
        except RequestError as e:
            logger.error(
                f"[{self.__class__.__name__}] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {event.from_user.id}")
            text, markup = e.to_user_message_with_markup()
            await event.answer(text, reply_markup=markup)
            return False
        except Exception as e:
            logger.exception(f"[{self.__class__.__name__}] –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
            await event.answer("üö® –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ –ø–æ–∑–∂–µ.")
            return False

class ShowDetailBudgetInfoHandler(BaseHandler):
    async def handle(self, event, state: FSMContext, context: dict = None):
        logger.debug(
            f"[{self.__class__.__name__}] –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è (–¥–µ—Ç–∞–ª—å–Ω–æ) –±—é–¥–∂–µ—Ç–∞ –∞–≤—Ç–æ—Ä–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {event.from_user.id}")
        try:
            budget = context["detail_budget"]
            await event.message.edit_text(self._format_budget(budget, index, len(budgets)),
                                          reply_markup=BudgetKeyboard().get_user_budgets_menu_keyboard(),
                                          parse_mode='HTML')
            return True
        except Exception as e:
            logger.exception(
                f"[{self.__class__.__name__}] –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –∫—ç—à-–±–æ–∫—Å–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
            await event.answer("üö® –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ –ø–æ–∑–∂–µ.")
            return False


    def _format_budget(self, budget: dict, index: int, total: int) -> str:
        category = budget.get("category", {})
        subcategory = budget.get("subcategory", {})
        user_cashbox = budget.get("user_cashbox", {})
        user = budget.get("user", {})

        return (
            f"üìä <b>–ë—é–¥–∂–µ—Ç</b> {index + 1}/{total}\n\n"
            f"üóÇÔ∏è <b>–ö–∞—Ç–µ–≥–æ—Ä–∏—è:</b> {(category.get('name', '‚Äî'))}\n"
            f"üìÅ <b>–ü–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è:</b> {(subcategory.get('name', '‚Äî'))}\n"
            f"üíº <b>–ö—ç—à–±–æ–∫—Å:</b> {(user_cashbox.get('custom_name') or user_cashbox.get('name', '‚Äî'))}\n"
            f"üìÖ <b>–ú–µ—Å—è—Ü:</b> {budget.get('month')}.{budget.get('year')}\n"
            f"üí∞ <b>–°—É–º–º–∞:</b> {budget.get('amount')} {(budget.get('currency', '‚Äî'))}\n"
            f"üîÅ <b>–ü–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è:</b> {'–î–∞' if budget.get('is_recurring') else '–ù–µ—Ç'}\n"
            f"üîí <b>–ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω:</b> {'–î–∞' if budget.get('is_locked') else '–ù–µ—Ç'}\n"
            f"‚úèÔ∏è <b>–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:</b> {(budget.get('comment', '‚Äî'))}\n"
            f"üë§ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b> {(user.get('first_name', ''))} {(user.get('last_name', ''))} (@{user.get('username', '‚Äî')})"
        )
